# CAN通信技术学习笔记

## 一、CAN通信概述
CAN（Controller Area Network，控制器局域网）是一种基于广播机制的串行通信协议，由博世公司为汽车电子领域开发，后广泛应用于工业控制、智能设备等多节点通信场景。其核心特点包括：支持多节点互联、具备高可靠性（错误检测与纠正）、实时性强（优先级仲裁机制）、布线成本低（双线制总线），适用于对通信稳定性和响应速度要求较高的分布式控制系统。


## 二、核心技术细节

### 1. 数据传输机制
- **多数据传输特性**：物理层为半双工串行传输，无法并行传输多条数据，但通过**总线仲裁机制**实现分时复用。多个节点可“同时”发起传输请求，通过优先级判定有序发送，宏观上实现多条数据帧的连续传输。
- **帧结构**：CAN帧按功能分为数据帧、远程帧、错误帧、过载帧，其中数据帧为核心，结构如下：
  - 帧起始（SOF）：1位显性电平，标志帧开始；
  - 仲裁场：标准帧11位（含ID和RTR位），扩展帧29位（含扩展ID、RTR、IDE等），用于优先级仲裁；
  - 控制场：含数据长度码（DLC，0-8字节）和保留位；
  - 数据场：存储实际传输数据；
  - CRC场：16位校验码，检测传输错误；
  - 应答场：2位，接收节点确认接收成功；
  - 帧结束（EOF）：7位隐性电平，标志帧结束。


### 2. 总线仲裁机制
- **仲裁逻辑**：当多个节点同时发送数据时，通过比较仲裁场的**显隐电平**（显性0优先级高于隐性1）判定优先级。优先级低的节点（发送隐性电平时检测到总线为显性）主动停止发送，转为接收状态。
- **仲裁场作用**：不仅决定发送优先级，其标识符（ID）还承载消息语义（如数据类型、用途），替代传统“地址”功能。
- **仲裁失败处理**：失败节点的消息暂存于发送缓冲区，待总线空闲后重试，可能因高负载或优先级设计不合理导致信息堆积（需通过缓存管理和流量控制优化）。


### 3. 关键组件：CAN芯片
- **定义**：实现CAN协议底层逻辑的集成电路，负责帧收发、仲裁、错误处理等。
- **分类**：
  - 独立CAN控制器（如SJA1000、MCP2515）：需配合MCU和收发器使用；
  - 集成CAN控制器的MCU（如STM32F103、NXP Kinetis）：简化硬件设计；
  - CAN收发器（如TJA1050、MCP2562）：物理层信号转换，增强驱动能力。


### 4. 寻址与过滤机制
- **无明确地址设计**：CAN为广播总线，所有节点均可接收总线上的消息，通过以下机制筛选有效信息：
  - **ID语义化定义**：系统设计时为特定数据分配唯一ID（如发动机转速对应ID=0x123），标识消息用途；
  - **过滤机制**：节点通过硬件过滤器（验收码+屏蔽码）和软件过滤，仅处理感兴趣的ID对应的消息，忽略无关内容。


## 三、基于HAL库的CAN通信关键函数
在STM32等嵌入式系统中，HAL（Hardware Abstraction Layer）库提供了封装后的CAN通信接口，简化了底层寄存器操作。核心函数如下：

### 1. 初始化与配置
- **`HAL_CAN_Init(CAN_HandleTypeDef *hcan)`**  
  功能：初始化CAN控制器，包括时钟配置、工作模式（正常模式/回环模式）、波特率等。  
  参数：`hcan`为CAN句柄结构体，包含外设基地址、初始化参数等。  
  说明：需先通过`MX_CAN_Init()`生成基础配置，再调用此函数使能外设。

- **`HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig)`**  
  功能：配置CAN过滤器，实现硬件级消息筛选。  
  参数：`sFilterConfig`包含过滤器编号、模式（列表模式/掩码模式）、标识符（ID）和屏蔽码等。  
  示例：配置接收ID=0x123的标准帧时，需设置过滤器ID和屏蔽码匹配该ID。

### 2. 数据发送
- **`HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pTxHeader, uint8_t *pData, uint32_t *pTxMailbox)`**  
  功能：将数据帧添加到发送邮箱，等待总线空闲时发送。  
  参数：  
  - `pTxHeader`：发送帧头，包含ID、帧类型（标准/扩展）、数据长度（DLC）等；  
  - `pData`：待发送数据缓冲区；  
  - `pTxMailbox`：输出参数，返回使用的发送邮箱编号（0-2）。  
  说明：发送成功后需通过`HAL_CAN_GetTxMailboxesFreeLevel()`检查邮箱状态。

### 3. 数据接收
- **`HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pRxHeader, uint8_t *pData)`**  
  功能：从接收FIFO中读取已接收的消息。  
  参数：  
  - `RxFifo`：指定接收FIFO（0或1）；  
  - `pRxHeader`：输出接收帧头信息（如ID、DLC等）；  
  - `pData`：输出接收数据缓冲区。  
  说明：需先通过`HAL_CAN_GetRxFifoFillLevel()`判断FIFO是否有数据。

### 4. 中断与状态处理
- **`HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)`**  
  功能：发送邮箱0完成中断回调函数，可用于处理发送完成后的逻辑（如释放缓冲区）。

- **`HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)`**  
  功能：接收FIFO0有新消息中断回调函数，通常在此处调用`HAL_CAN_GetRxMessage()`读取数据。

- **`HAL_CAN_GetError(CAN_HandleTypeDef *hcan)`**  
  功能：获取CAN控制器错误状态（如仲裁错误、CRC错误），用于故障诊断。


## 四、应用场景
- 汽车电子：发动机控制、ABS、车身电子等节点间数据交互；
- 工业控制：PLC、传感器、执行器的短距离通信；
- 智能设备：智能家居、医疗设备的多模块协同。


## 五、总结
CAN通信通过优先级仲裁、广播+过滤机制、硬件级错误处理，在多节点场景下实现了高效、可靠的实时通信。其无地址设计简化了系统架构，而ID的双重作用（优先级+语义标识）是平衡灵活性与精准性的核心设计。基于HAL库的编程接口（如过滤器配置、消息收发函数）进一步降低了开发难度，实际应用中需结合总线负载优化和错误处理机制，确保系统稳定性。